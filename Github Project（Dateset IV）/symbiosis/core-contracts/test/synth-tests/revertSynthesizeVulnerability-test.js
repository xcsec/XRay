const { expect } = require("chai");
const { ethers } = require("hardhat");
const library = require("./library");

const hardhatChainID = 31337;
const trustedForwarder = "0x83A54884bE4657706785D7309cf46B58FE5f6e8a";
const mintableAmount = 1000; // 10%
const stableBridgingFee = 100;
const syntAmount = 1000;

describe("Should check snts", function () {
	let portal,
		firstSynthesis,
		secondSynthesis,
		testToken,
		sTestToken1,
		sTestToken2,
		sTestTokenAddr1,
		sTestTokenAddr2,
		bridge,
		oppositeBridge,
		firstSyntFabric,
		secondSyntFabric,
		owner,
		user;

	beforeEach(async () => {
		[owner, user] = await ethers.getSigners();

		// NOTE: we can't use library here because here is specific logic: two synthesis contracts, two fabrics and etc.
		const Wrapper = await ethers.getContractFactory("WETH9");
		const Bridge = await ethers.getContractFactory("BridgeV2");
		const Portal = await ethers.getContractFactory("Portal");
		const Synthesis = await ethers.getContractFactory("Synthesis");
		const TestToken = await ethers.getContractFactory("GenericERC20");
		const Fabric = await ethers.getContractFactory("SyntFabric");
		const STestToken = await ethers.getContractFactory("SyntERC20");
		const MetaRouter = await ethers.getContractFactory("MetaRouter");

		let wrapper = await Wrapper.deploy();

		bridge = await upgrades.deployProxy(Bridge, [owner.address]);
		oppositeBridge = await upgrades.deployProxy(Bridge, [owner.address]);
		console.log("Bridge deployed to:", bridge.address);
		console.log("Opposite bridge deployed to:", oppositeBridge.address);

		metaRouter = await MetaRouter.deploy();
		testToken = await TestToken.deploy("sTT", "sTTT");

		portal = await upgrades.deployProxy(Portal, [
			bridge.address,
			trustedForwarder,
			wrapper.address,
			testToken.address,
			metaRouter.address,
		]);

		firstSynthesis = await upgrades.deployProxy(Synthesis, [
			oppositeBridge.address,
			trustedForwarder,
			metaRouter.address,
		]);

		secondSynthesis = await upgrades.deployProxy(Synthesis, [
			oppositeBridge.address,
			trustedForwarder,
			metaRouter.address,
		]);

		firstSyntFabric = await upgrades.deployProxy(Fabric, [
			firstSynthesis.address,
		]);
		secondSyntFabric = await upgrades.deployProxy(Fabric, [
			secondSynthesis.address,
		]);

		await testToken.mint(owner.address, mintableAmount);
		await testToken.approve(portal.address, mintableAmount);

		//set minimal token price
		await portal.setTokenThreshold(testToken.address, 100);

		await firstSyntFabric.createRepresentationByAdmin(
			testToken.address,
			hardhatChainID,
			"sTT",
			"sTT",
			18
		);
		await firstSynthesis.setFabric(firstSyntFabric.address);

		await secondSyntFabric.createRepresentationByAdmin(
			testToken.address,
			hardhatChainID,
			"sTT",
			"sTT",
			18
		);
		await secondSynthesis.setFabric(secondSyntFabric.address);

		let syntKey1 = ethers.utils.solidityKeccak256(
			["address", "uint256"],
			[testToken.address, hardhatChainID]
		);
		sTestTokenAddr1 = await firstSyntFabric.getSyntRepresentationByKey(
			syntKey1
		);

		let syntKey2 = ethers.utils.solidityKeccak256(
			["address", "uint256"],
			[testToken.address, hardhatChainID]
		);
		sTestTokenAddr2 = await secondSyntFabric.getSyntRepresentationByKey(
			syntKey2
		);

		console.log("synt representation 1 is ", sTestTokenAddr1);
		console.log("synt representation 2 is ", sTestTokenAddr2);

		sTestToken1 = await STestToken.attach(sTestTokenAddr1);
		sTestToken2 = await STestToken.attach(sTestTokenAddr2);
		console.log("sTestToken1 attached to ", sTestToken1.address);
		console.log("sTestToken2 attached to ", sTestToken2.address);

		await bridge.setTransmitterStatus(portal.address, true);
		await oppositeBridge.setTransmitterStatus(firstSynthesis.address, true);
		await oppositeBridge.setTransmitterStatus(
			secondSynthesis.address,
			true
		);
	});

	it("Should check revertSynthesize vulnerability (2 synthesis contracts on one chain)", async () => {
		let clientId = ethers.utils.formatBytes32String("some client id");
		let txSynt = await portal.synthesize(
			stableBridgingFee,
			testToken.address,
			syntAmount,
			user.address,
			firstSynthesis.address,
			oppositeBridge.address,
			user.address,
			hardhatChainID,
			clientId
		);
		let syntReceipt = await txSynt.wait();

		let synthesizeRequest = syntReceipt.events.filter((x) => {
			return x.event == "SynthesizeRequest";
		});
		let syntTxID = synthesizeRequest[0].args[0];

		let syntOracleRequestArgs = await library.catchOracleRequest(
			syntReceipt
		);

		let bytesSyntSelector = syntOracleRequestArgs[1];
		let receiveSideSynt = syntOracleRequestArgs[2];

		await oppositeBridge.receiveRequestV2(
			bytesSyntSelector,
			receiveSideSynt
		);

		expect(syntAmount - stableBridgingFee).to.equal(
			await sTestToken1.balanceOf(user.address)
		);

		let txRevertSynt = await secondSynthesis
			.connect(user)
			.revertSynthesizeRequest(
				stableBridgingFee,
				syntTxID,
				portal.address,
				bridge.address,
				hardhatChainID,
				clientId
			);

		let revertSyntReceipt = await txRevertSynt.wait();
		let revertSyntOracleRequestArgs = await library.catchOracleRequest(
			revertSyntReceipt
		);

		let bytesRevertSyntSelector = revertSyntOracleRequestArgs[1];
		let receiveSideRevertSynt = revertSyntOracleRequestArgs[2];

		let otherSideCall = bridge.receiveRequestV2(
			bytesRevertSyntSelector,
			receiveSideRevertSynt
		);

		// expect that call should be reverted because transaction doesn't exist
		await expect(otherSideCall).to.be.revertedWith(
			"Symb: state not open or tx does not exist"
		);
	});
});
